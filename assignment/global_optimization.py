#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 21 15:36:06 2022

@author: jimmy
"""

# Теперь попробуем применить к той же функции f(x) метод глобальной оптимизации — дифференциальную эволюцию.
# Изучите документацию и примеры использования функции scipy.optimize.differential_evolution.
# Обратите внимание, что границы значений аргументов функции представляют собой список кортежей (list, 
# в который помещены объекты типа tuple). Даже если у вас функция одного аргумента, возьмите границы его значений 
# в квадратные скобки, чтобы передавать в этом параметре список из одного кортежа, т.к. в реализации scipy.optimize.differential_evolution
# длина этого списка используется чтобы определить количество аргументов функции.
# Запустите поиск минимума функции f(x) с помощью дифференциальной эволюции на промежутке [1, 30]. Полученное значение функции в точке минимума - 
# ответ в задаче 2. Запишите его с точностью до второго знака после запятой. В этой задаче ответ - только одно число.
# Заметьте, дифференциальная эволюция справилась с задачей поиска глобального минимума на отрезке, т.к. по своему устройству она предполагает борьбу 
# с попаданием в локальные минимумы.
# Сравните количество итераций, потребовавшихся BFGS для нахождения минимума при хорошем начальном приближении, с количеством итераций, 
# потребовавшихся дифференциальной эволюции. При повторных запусках дифференциальной эволюции количество итераций будет меняться, но в этом примере,
# скорее всего, оно всегда будет сравнимым с количеством итераций BFGS. Однако в дифференциальной эволюции за одну итерацию требуется выполнить гораздо больше действий,
# чем в BFGS. Например, можно обратить внимание на количество вычислений значения функции (nfev) и увидеть, что у BFGS оно значительно меньше. 
# Кроме того, время работы дифференциальной эволюции очень быстро растет с увеличением числа аргументов функции.

from math import sin, exp
import numpy as np
import matplotlib.pyplot as plt


def func(x):
    return sin(x / 5.) * exp(x / 10.) + 5. * exp(-x/ 2.)


xarr = np.arange(1., 31.)
print (xarr)
print ("Shape x:", xarr.shape)
yarr = np.array([func(x) for x in xarr])
print(yarr)
print("Shape y:", yarr.shape)

plt.plot(xarr, yarr)
plt.grid(True)
plt.axis([0, 30, -15, 5])
plt.show()

from scipy.optimize import differential_evolution

bounds = [(1, 30)]
minFuncVal4 = differential_evolution(func, bounds)
print ("Min f(x) (diff_evolution): ", round(minFuncVal4.fun, 3), "for x = ", minFuncVal4.x)
print ("Number of iterations: ", minFuncVal4.nit)

with open("docvalue.txt", "w") as file:
    file.write(str(round(minFuncVal4.fun, 2)))
    
    
